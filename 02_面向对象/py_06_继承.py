# -----------------------------------知识点-------------------------------------------
"""
面向对象三大特性
    1.封装 根据职责将属性和方法封装到一个抽象的类中
    2.继承 实现代码的重用，相同的代码不需要重复的编写
    3.多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度

    1>. 子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发(公共方法)
        子类中应该根据职责，封装子类特有的属性和方法
        当父类 的方法实现不能满足子类需求时，可以对方法进行 重写(override)
    继承语法:
        class 类名(父类名):              单继承
            pass

        class 子类名(父类名1, 父类名2...):    多继承
            pass

    2>.方法的重写
        1>.覆盖父类的方法
            子类中定义了一个和父类同名的方法并且实现重写之后，在运行时，只会调用子类中重写的方法
        2>.对父类方法进行 扩展
            1>.在子类中重写父类的方法
            2>.在需要的位置使用 super().父类方法 来调用父类方法的执行
            3>.代码其他的位置针对子类的需求，编写子类特有的代码实现

    3>.多继承(***注意:在子类中可能会继承父类中可能会存在相同的属性名或者方法名-->因此要注意***)--重要
        子类 可以拥有多个父类，并且具有所有父类的属性和方法(公共的)  ( 例如：孩子会继承自己父亲和母亲的特性)
        问题:不同的父类中存在同名的方法，子类对象在调用方法时，会调用哪一个父类中的方法呢？
            提示：开发时，应该尽量避免这种容易产生混淆的情况！如果父类之间存在同名的属性或者方法，应该尽量避免使用多继承

    ****   MRO 是 method resolution order，主要用于在多继承时判断 方法、属性 的调用路径
        类名.__mro__     例如:    print(C.__mro__)
    ****  Python 2.x 中定义类时，如果没有指定父类，则不会以 object 作为 基类
          Python 3.x 中定义类时，如果没有指定父类，会 默认使用 object 作为该类的 基类
          保证编写的代码能够同时在 Python 2.x 和 Python 3.x 运行
          今后在定义类时，如果没有父类，建议统一继承自 object

          class 类名(object):
                pass
"""
# -----------------------------------练习-------------------------------------------
'''
'''
print("# -------------------------单继承------------------------------------")


class Animal:
    """定义父类"""

    def eat(self):
        print("吃东西")

    def drink(self):
        print("喝东西")

    def run(self):
        print("跑步")


class Dog(Animal):
    """定义子类"""

    #  添加自己的方法
    def run12(self):
        print("自己方法--->小狗跑步")

    #  重写父类的方法
    def drink(self):
        super().drink()
        print("重写方法--->小狗喝的")


# 调用方法
dao = Dog()
dao.run12()
dao.drink()

print("# -------------------------多继承------------------------------------")


class A:

    def demo1(self):
        print("实例demo1--->A")

    def test1(self):
        print("测试")


class B:

    def demo1(self):
        print("实例demo2--->B")

    def test2(self):
        print("测试")


class C(A, B):

    def demo3(self):
        print("自己的方法--->C")


print(C.__mro__)  # MRO是method resolution order，主要用于在多继承时判断方法、属性 的调用路径 (此处为类型 C的调用顺序)

c = C()
c.demo1()  # 如果父类有重名的方法,先继承那个类就先用哪个类中的方法
c.demo3()
c.test1()
c.test2()
